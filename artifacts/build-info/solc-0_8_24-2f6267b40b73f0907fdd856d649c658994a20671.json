{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_24-2f6267b40b73f0907fdd856d649c658994a20671",
  "solcVersion": "0.8.24",
  "solcLongVersion": "0.8.24+commit.e11b9ed9",
  "userSourceNameMap": {
    "contracts/SentrixLicensing.sol": "project/contracts/SentrixLicensing.sol",
    "contracts/SentrixRegistry.sol": "project/contracts/SentrixRegistry.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/SentrixLicensing.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ninterface ISentrixRegistry {\n    function assetOwner(uint256 assetId) external view returns (address);\n}\n\n/// @title SentrixLicensing\n/// @notice Simple programmable license marketplace for Sentrix IP assets\ncontract SentrixLicensing {\n    enum Status {\n        Pending,\n        Active,\n        Revoked\n    }\n\n    struct LicenseListing {\n        uint256 id;\n        uint256 assetId;\n        address licensor;\n        address licensee;\n        uint256 fee;\n        uint64 startDate;\n        uint64 endDate;\n        string termsURI;\n        Status status;\n    }\n\n    ISentrixRegistry public immutable registry;\n    uint256 private _nextLicenseId = 1;\n\n    mapping(uint256 => LicenseListing) private _licenses;\n    mapping(uint256 => uint256[]) private _licensesByAsset;\n\n    event LicenseCreated(\n        uint256 indexed licenseId,\n        uint256 indexed assetId,\n        address indexed licensor,\n        uint256 fee,\n        string termsURI\n    );\n\n    event LicenseAccepted(\n        uint256 indexed licenseId,\n        address indexed licensee\n    );\n\n    event LicenseRevoked(uint256 indexed licenseId);\n\n    error NotAssetOwner(address caller, uint256 assetId);\n    error InvalidLicensee();\n    error InvalidDates();\n    error InvalidFee();\n    error LicenseNotFound(uint256 licenseId);\n    error InvalidStatus();\n\n    constructor(address registryAddress) {\n        registry = ISentrixRegistry(registryAddress);\n    }\n\n    function createLicense(\n        uint256 assetId,\n        uint64 startDate,\n        uint64 endDate,\n        uint256 fee,\n        string calldata termsURI,\n        address licensee\n    ) external returns (uint256 licenseId) {\n        if (registry.assetOwner(assetId) != msg.sender) {\n            revert NotAssetOwner(msg.sender, assetId);\n        }\n        if (endDate != 0 && endDate <= startDate) {\n            revert InvalidDates();\n        }\n        if (fee == 0) {\n            revert InvalidFee();\n        }\n        // licensee can be left blank to create an open listing\n\n        licenseId = _nextLicenseId++;\n\n        _licenses[licenseId] = LicenseListing({\n            id: licenseId,\n            assetId: assetId,\n            licensor: msg.sender,\n            licensee: licensee,\n            fee: fee,\n            startDate: startDate,\n            endDate: endDate,\n            termsURI: termsURI,\n            status: Status.Pending\n        });\n\n        _licensesByAsset[assetId].push(licenseId);\n\n        emit LicenseCreated(licenseId, assetId, msg.sender, fee, termsURI);\n    }\n\n    function acceptLicense(uint256 licenseId) external payable {\n        LicenseListing storage listing = _licenses[licenseId];\n        if (listing.licensor == address(0)) {\n            revert LicenseNotFound(licenseId);\n        }\n        if (listing.status != Status.Pending) {\n            revert InvalidStatus();\n        }\n        if (msg.sender != listing.licensee) {\n            if (listing.licensee != address(0)) {\n                revert InvalidLicensee();\n            }\n        }\n\n        if (listing.licensee == address(0)) {\n            listing.licensee = msg.sender;\n        } else if (msg.sender != listing.licensee) {\n            revert InvalidLicensee();\n        }\n        if (msg.value != listing.fee) {\n            revert InvalidFee();\n        }\n\n        listing.status = Status.Active;\n\n        (bool success, ) = listing.licensor.call{value: msg.value}(\"\");\n        if (!success) {\n            revert InvalidFee();\n        }\n\n        emit LicenseAccepted(licenseId, msg.sender);\n    }\n\n    function revokeLicense(uint256 licenseId) external {\n        LicenseListing storage listing = _licenses[licenseId];\n        if (listing.licensor == address(0)) {\n            revert LicenseNotFound(licenseId);\n        }\n        if (msg.sender != listing.licensor) {\n            revert NotAssetOwner(msg.sender, listing.assetId);\n        }\n\n        listing.status = Status.Revoked;\n\n        emit LicenseRevoked(licenseId);\n    }\n\n    function getLicense(uint256 licenseId) external view returns (LicenseListing memory) {\n        LicenseListing memory listing = _licenses[licenseId];\n        if (listing.licensor == address(0)) {\n            revert LicenseNotFound(licenseId);\n        }\n        return listing;\n    }\n\n    function getLicensesByAsset(uint256 assetId) external view returns (LicenseListing[] memory licenses) {\n        uint256[] storage ids = _licensesByAsset[assetId];\n        licenses = new LicenseListing[](ids.length);\n        for (uint256 i = 0; i < ids.length; i++) {\n            licenses[i] = _licenses[ids[i]];\n        }\n    }\n\n    function getOpenLicenses() external view returns (LicenseListing[] memory licenses) {\n        uint256 openCount;\n        for (uint256 i = 1; i < _nextLicenseId; i++) {\n            if (_licenses[i].status == Status.Pending) {\n                openCount++;\n            }\n        }\n\n        licenses = new LicenseListing[](openCount);\n        uint256 cursor;\n        for (uint256 i = 1; i < _nextLicenseId; i++) {\n            if (_licenses[i].status == Status.Pending) {\n                licenses[cursor++] = _licenses[i];\n            }\n        }\n    }\n}\n\n"
      },
      "project/contracts/SentrixRegistry.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/// @title SentrixRegistry\n/// @notice Minimal registry for tracking Story Protocol IP assets on-chain\ncontract SentrixRegistry {\n    struct Asset {\n        uint256 id;\n        address owner;\n        string title;\n        string category;\n        string metadataURI;\n        uint64 createdAt;\n    }\n\n    uint256 private _nextAssetId = 1;\n\n    mapping(uint256 => Asset) private _assets;\n    mapping(address => uint256[]) private _assetsByOwner;\n\n    event AssetRegistered(\n        uint256 indexed assetId,\n        address indexed owner,\n        string title,\n        string category,\n        string metadataURI\n    );\n\n    event AssetMetadataUpdated(\n        uint256 indexed assetId,\n        string metadataURI\n    );\n\n    error AssetNotFound(uint256 assetId);\n    error NotAssetOwner(address caller, uint256 assetId);\n    error InvalidMetadata();\n\n    /// @notice Register a new IP asset and associate arbitrary metadata (IPFS, Arweave, etc.)\n    function registerAsset(\n        string calldata title,\n        string calldata category,\n        string calldata metadataURI\n    ) external returns (uint256 assetId) {\n        if (bytes(title).length == 0 || bytes(metadataURI).length == 0) {\n            revert InvalidMetadata();\n        }\n\n        assetId = _nextAssetId++;\n\n        Asset memory asset = Asset({\n            id: assetId,\n            owner: msg.sender,\n            title: title,\n            category: category,\n            metadataURI: metadataURI,\n            createdAt: uint64(block.timestamp)\n        });\n\n        _assets[assetId] = asset;\n        _assetsByOwner[msg.sender].push(assetId);\n\n        emit AssetRegistered(assetId, msg.sender, title, category, metadataURI);\n    }\n\n    /// @notice Update the metadata URI for an existing IP asset\n    function updateMetadata(uint256 assetId, string calldata metadataURI) external {\n        if (bytes(metadataURI).length == 0) {\n            revert InvalidMetadata();\n        }\n\n        Asset storage asset = _assets[assetId];\n        if (asset.owner == address(0)) {\n            revert AssetNotFound(assetId);\n        }\n        if (asset.owner != msg.sender) {\n            revert NotAssetOwner(msg.sender, assetId);\n        }\n\n        asset.metadataURI = metadataURI;\n\n        emit AssetMetadataUpdated(assetId, metadataURI);\n    }\n\n    /// @notice Return the owner of an asset\n    function assetOwner(uint256 assetId) external view returns (address) {\n        address owner = _assets[assetId].owner;\n        if (owner == address(0)) {\n            revert AssetNotFound(assetId);\n        }\n        return owner;\n    }\n\n    /// @notice Fetch metadata for an asset\n    function getAsset(uint256 assetId) external view returns (Asset memory) {\n        Asset memory asset = _assets[assetId];\n        if (asset.owner == address(0)) {\n            revert AssetNotFound(assetId);\n        }\n        return asset;\n    }\n\n    /// @notice Return all assets owned by an address\n    function getAssetsByOwner(address owner) external view returns (Asset[] memory assets) {\n        uint256[] storage ids = _assetsByOwner[owner];\n        assets = new Asset[](ids.length);\n        for (uint256 i = 0; i < ids.length; i++) {\n            assets[i] = _assets[ids[i]];\n        }\n    }\n\n    /// @notice How many assets have been registered\n    function totalAssets() external view returns (uint256) {\n        return _nextAssetId - 1;\n    }\n}\n\n"
      }
    }
  }
}